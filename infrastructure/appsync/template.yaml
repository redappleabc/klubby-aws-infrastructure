
AWSTemplateFormatVersion: '2010-09-09'
Description: AppSync Stack
Parameters:
  ProjectName:
    Type: String
    Default: klubby
    Description: Unique Auth Name for Cognito Resources
  Stage:
    Type: String
    Default: dev
    Description: Stage of build
  UserPoolId:
    Type: AWS::SSM::Parameter::Value<String>
    Default: userpool-id-dev
    Description: user pool id from SSM
  UserTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: user-table-name-dev
    Description: user table name
Resources:
  GraphQLApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub '${ProjectName}-graphql-${Stage}'
      AuthenticationType: "AMAZON_COGNITO_USER_POOLS"
      UserPoolConfig:
        UserPoolId: !Ref UserPoolId
        AwsRegion: us-east-1
        DefaultAction: ALLOW
        # Ref: defaultAction
  Schema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      # DefinitionS3Location:
      #   Ref: graphQlSchemaS3DescriptionLocation
      Definition: |
        schema {
            query: Query
            mutation: Mutation
        }

        type Conversation {
          #  The Conversation's timestamp.
          createdAt: String
          #  A unique identifier for the Conversation.
          id: ID!
          #  The Conversation's messages.
          messages(after: String, first: Int): MessageConnection
          #  The Conversation's name.
          name: String!
        }

        type Message {
          #  The author object. Note: `authorId` is only available because we list it in `extraAttributes` in `Conversation.messages`
          author: User
          #  The message content.
          content: String!
          #  The id of the Conversation this message belongs to. This is the table primary key.
          conversationId: ID!
          #  The message timestamp. This is also the table sort key.
          createdAt: String
          #  Generated id for a message -- read-only
          id: ID!
          #  Flag denoting if this message has been accepted by the server or not.
          isSent: Boolean
          recipient: User
          sender: String
        }

        type MessageConnection {
          messages: [Message]
          nextToken: String
        }

        type User {
          username: String!
          wallets: String
          #  A user's enrolled Conversations. This is an interesting case. This is an interesting pagination case.
          conversations(after: String, first: Int): UserConverstationsConnection
        }

        type UserConversations {
          associated: [UserConversations]
          conversation: Conversation
          conversationId: ID!
          user: User
          userId: ID!
        }

        type UserConverstationsConnection {
          nextToken: String
          userConversations: [UserConversations]
        }

        type Query {
            getUsers: [User]
            #TODO make this [String]
            getUserWallets(username: String!): User
        }

        type Mutation {
            #  Create a Conversation. Use some of the cooked in template functions for UUID and DateTime.
            createConversation(createdAt: String, id: ID!, name: String!): Conversation
            # addUser(username: String!): User
            updateUser(username: String!,wallets: String!): User
        }

  UserDynamoDBTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "UserDynamoDBTable"
      Description: The Post DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref UserTableName

  AppSyncDynamoDBRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: Amplify
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: dynamodb:*
                Resource: '*'

  ### Resolvers ###
  CreateConversationMutationResolver:
    Type: "AWS::AppSync::Resolver"
    Properties:
      ApiId: !GetAtt chatQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createConversation"
      DataSourceName: !GetAtt conversationsTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "PutItem",
          "key": {
              "id": { "S" : "${context.arguments.id}"}
          },
          "attributeValues" : {
             "id": {  "S": "${context.arguments.id}" },
             "name": {  "S": "${context.arguments.name}" }
             #if(${context.arguments.createdAt}) ,"createdAt": { "S": "${context.arguments.createdAt}"} #end
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  GetUsersResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getUsers
      DataSourceName: !GetAtt UserDynamoDBTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "Scan",
            ## Add 'limit' and 'nextToken' arguments to this field in your schema to implement pagination. **
            ## "limit": $util.defaultIfNull(${ctx.args.limit}, 20),
            ## "nextToken": $util.toJson($util.defaultIfNullOrBlank($ctx.args.nextToken, null))
        }
      ResponseMappingTemplate: |
        #**
            Return a flat list of results from a Query or Scan operation.
        *#
        $util.toJson($ctx.result.items)

  GetUserWalletsResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getUserWallets
      DataSourceName: !GetAtt UserDynamoDBTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
                "username": $util.dynamodb.toDynamoDBJson($ctx.args.username),
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)

  UpdateUserResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateUser
      DataSourceName: !GetAtt UserDynamoDBTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "UpdateItem",
            "key" : {
                "username" : $util.dynamodb.toDynamoDBJson($context.arguments.username)
            },
            "update" : {
                "expression" : "SET wallets = :wallets",
                ## "expressionNames": {
                ##     "#url" : "url"
                ## },
                "expressionValues": {
                    ":wallets" : $util.dynamodb.toDynamoDBJson($context.arguments.wallets)
                }
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)