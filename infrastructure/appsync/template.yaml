
AWSTemplateFormatVersion: '2010-09-09'
Description: AppSync Stack
Parameters:
  ProjectName:
    Type: String
    Default: klubby
    Description: Unique Auth Name for Cognito Resources
  Stage:
    Type: String
    Default: dev
    Description: Stage of build
  UserPoolId:
    Type: AWS::SSM::Parameter::Value<String>
    Default: userpool-id-${Stage}
    Description: user pool id from SSM
  UserTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: user-table-name-${Stage}
    Description: user table name
  ConversationTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: conversation-table-name-${Stage}
    Description: conversation table name
  UserConversationBridgeTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: userconversationbridge-table-name-${Stage}
    Description: user conversation table name
  MessageTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: message-table-name-${Stage}
    Description: message table name
Resources:
  GraphQLApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub '${ProjectName}-graphql-${Stage}'
      AuthenticationType: "AMAZON_COGNITO_USER_POOLS"
      UserPoolConfig:
        UserPoolId: !Ref UserPoolId
        AwsRegion: us-east-1
        DefaultAction: ALLOW
        # Ref: defaultAction
  Schema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      # DefinitionS3Location:
      #   Ref: graphQlSchemaS3DescriptionLocation
      Definition: |
        schema {
            query: Query
            mutation: Mutation
            subscription: Subscription
        }

        type Conversation {
          #  The Conversation's timestamp.
          createdAt: String
          #  A unique identifier for the Conversation.
          id: ID!
          #  The Conversation's messages.
          messages(after: String, first: Int): MessageConnection
        }

        type Message {
          #  The message content.
          content: String!
          #  The id of the Conversation this message belongs to. This is the table primary key.
          conversationId: ID!
          #  The message timestamp. This is also the table sort key.
          createdAt: String
          updatedAt: String
          #  Generated id for a message -- read-only
          id: ID!
          #  Flag denoting if this message has been accepted by the server or not.
          isSent: Boolean
          sender: String
        }

        type MessageConnection {
          messages: [Message]
          nextToken: String
        }

        type User {
          username: String!
          wallets: String
          #  A user's enrolled Conversations. This is an interesting case. This is an interesting pagination case.
          conversations(after: String, first: Int): [UserConversationBridge]
        }

        type UserConversationBridge {
          # The user conversation name
          name: String
          # The other user name
          associated: String
          # The conversation related me
          conversation: Conversation
          # latest message id  which other user has read
          read: String

          conversationId: ID!
          username: ID!
        }


        type Query {
          #get all users
          getAllUsers: [User]

          #get users whose username starts with _username
          searchUsers(username: String!): [User]

          # get user wallets
          getUserWallets(username: String!): User

          #  Scan through all values of type 'Message'. Use the 'after' and 'before' arguments with the 'nextToken' returned by the 'MessageConnection' result to fetch pages.
          getAllMessages(after: String, conversationId: ID!, first: Int): [Message]

          #  Scan through all values of type 'MessageConnection'. Use the 'after' and 'before' arguments with the 'nextToken' returned by the 'MessageConnectionConnection' result to fetch pages.
          getAllMessageConnections(after: String, conversationId: ID!, first: Int): MessageConnection

          # TODO what does this do
          getAllMessagesFrom(after: String, conversationId: ID!, first: Int, sender: String!): [Message] 

          # get Me
          getMe: User

          test: User
        }

        type Mutation {
          #  Create a Conversation. Use some of the cooked in template functions for UUID and DateTime.
          createConversation: Conversation

          # Delete the Conversation
          removeConversation(conversationId: ID!): Conversation

          # Delete  UserConversationBridge
          removeUserConversationBridge(username: ID!, conversationId: ID!): UserConversationBridge

          #  Create a message in a Conversation.
          createMessage(content: String!, conversationId: ID!): Message

          # Create a user conversation.
          createUserConversationBridge(conversationId: ID!, username: ID!, name: String): UserConversationBridge

          # addUser(username: String!): User
          updateUser(username: String!,wallets: String!): User

          # set message id which user read
          setRead(conversationId: ID!, username: ID!, messageId: ID!): UserConversationBridge

          # remove message in Messages table
          removeMessage(conversationId: ID!, id: String!): Message

          # edit message in Messages table
          editMessage(conversationId: ID!, id: String!, content: String!): Message

        }

        type Subscription  {
          #  Subscribes to all new messages in a given Conversation.
          subscribeToNewMessage(conversationId: ID!): Message
            @aws_subscribe(mutations:["createMessage","editMessage"])

          subscribeToNewUserConversationBridge(username:ID!): UserConversationBridge
            @aws_subscribe(mutations: ["createUserConversationBridge"])

          subscribeToRemovedUserConversationBridge(username:ID!): UserConversationBridge
            @aws_subscribe(mutations: ["removeUserConversationBridge"])

          # Subscribes to all removed messages in a given Conversation
          subscribeToRemovedMessage(conversationId: ID!): Message
            @aws_subscribe(mutations: ["removeMessage"]) 
        }

  UserTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "UserDynamoDBTable"
      Description: The Post DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref UserTableName

  ConversationTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "ConversationDynamoDBTable"
      Description: The Conversation DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref ConversationTableName

  UserConversationBridgeTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "UserConversationBridgeDynamoDBTable"
      Description: The User Conversation DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref UserConversationBridgeTableName

  MessageTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "MessageDynamoDBTable"
      Description: Message DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref MessageTableName

  AppSyncDynamoDBRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: Amplify
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: dynamodb:*
                Resource: '*'

  ### Resolvers ###
  TestResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: test
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "GetItem",
          "key": {
              "username": { "S" : "${context.identity.username}"}
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  CreateConversationMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createConversation"
      DataSourceName: !GetAtt ConversationTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "PutItem",
          "key": {
              "id": { "S" : "$util.autoId()"}
          },
          "attributeValues" : {
             "id": {  "S": "$util.autoId()" },
             "createdAt": {  "S": "$util.time.nowEpochMilliSeconds()" }
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  # removeConversationMutationResolver:
  #   Type: "AWS::AppSync::Resolver"
  #   DependsOn: Schema
  #   Properties:
  #     ApiId: !GetAtt GraphQLApi.ApiId
  #     TypeName: "Mutation"
  #     FieldName: "removeConversation"
  #     DataSourceName: !GetAtt ConversationTableDataSource.Name
  #     RequestMappingTemplate: !Sub 
  #       - | 
  #         #set($conversationId = $context.arguments.conversationId)
  #         #set($keys_1=[])
  #         #set($key_1={})
  #         $util.qr($key_1.put("id", $util.dynamodb.toString($conversationId)))
  #         $util.qr($keys_1.add($util.dynamodb.toMapValues($key_1)))

  #         #set($keys_2=[])
  #         #set($key_2={})
  #         $util.qr($key_2.put("conversationId", $util.dynamodb.toString($conversationId)))
  #         $util.qr($keys_2.add($util.dynamodb.toMapValues($key_2)))
         
  #         {
  #             "version" : "2018-05-29",
  #             "operation" : "BatchDeleteItem",
  #             "tables":{
  #               "${ConversationTable}":  $utils.toJson($keys_1),
  #               "${UserConversationBridgeTable}" :  $utils.toJson($keys_2)
  #             }
  #         }
  #       - { 
  #           ConversationTable: !Ref ConversationTableName,
  #           UserConversationBridgeTable: !Ref UserConversationBridgeTableName
  #         }

  #     ResponseMappingTemplate: !Sub
  #       - |
  #         $utils.toJson($context.result.data["${ConversationTable}"])
  #       - { 
  #           ConversationTable: !Ref ConversationTableName
  #         }


  removeConversationMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "removeConversation"
      DataSourceName: !GetAtt ConversationTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "DeleteItem",
          "key" : {
            "id" : { "S" : "${context.arguments.conversationId}" }
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)


  CreateUserConversationBridgeMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createUserConversationBridge"
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "PutItem",
            "key": {
                "username": { "S" : "${context.arguments.username}"},
                "conversationId": { "S" : "${context.arguments.conversationId}"}
            },
            "attributeValues" : {
                "username": {  "S": "${context.arguments.username}" },
                "conversationId": {  "S": "${context.arguments.conversationId}" },
                "name": {  "S": "${context.arguments.name}" }
            }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)


  
  RemoveUserConversationBridgeMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "removeUserConversationBridge"
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "DeleteItem",
            "key": {
                "username": { "S" : "${context.arguments.username}"},
                "conversationId": { "S" : "${context.arguments.conversationId}"}
            }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)




  CreateMessageMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createMessage"
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "PutItem",
          "key" : {
              "conversationId" : { "S" : "${context.arguments.conversationId}" }
          },
          "attributeValues" : {
              "conversationId": {  "S": "${context.arguments.conversationId}" },
              "content": {  "S": "${context.arguments.content}" },
              "createdAt": {  "S": "$util.time.nowEpochMilliSeconds()" },
              "sender": {  "S": "${context.identity.username}" },
              "isSent": {  "BOOL": true },
              "id": { "S": "$util.time.nowEpochMilliSeconds()-$util.autoId()" }
          }
        }

      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  RemoveMessageMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "removeMessage"
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "DeleteItem",
          "key" : {
            "id" : { "S" : "${context.arguments.id}" },
            "conversationId": {"S" : "${context.arguments.conversationId}"}
          },
          "condition" : {
              "expression" : "#sender = :sender",
              "expressionNames" : {
                  "#sender" : "sender"
              },
              "expressionValues" : {
                  ":sender" : {"S": "${context.identity.username}"}
              }
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  
  EditMessageMutationResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: editMessage
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "UpdateItem",
            "key" : {
              "id" : { "S" : "${context.arguments.id}" },
              "conversationId": {"S" : "${context.arguments.conversationId}"}
            },
            "condition" : {
              "expression" : "#sender = :sender",
              "expressionNames" : {
                  "#sender" : "sender"
              },
              "expressionValues" : {
                  ":sender" : {"S": "${context.identity.username}"}
              }
            },
            "update" : {
                "expression" : "SET #content = :content, #updatedAt = :updatedAt",
                "expressionNames": {
                   "#content" : "content",
                   "#updatedAt" : "updatedAt"
                 },
                "expressionValues": {
                    ":content" : $util.dynamodb.toDynamoDBJson($context.arguments.content) ,
                    ":updatedAt" : {  "S": "$util.time.nowEpochMilliSeconds()" }
                }
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)


  GetAllUsersResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllUsers
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "Scan",
            "filter" : {
              "expression" : "#username <> :username",
              "expressionNames" : {
                  "#username" : "username"
              },
              "expressionValues" : {
                  ":username" : {"S": "${context.identity.username}"}
              }
          },
            ## Add 'limit' and 'nextToken' arguments to this field in your schema to implement pagination. **
            ## "limit": $util.defaultIfNull(${ctx.args.limit}, 20),
            ## "nextToken": $util.toJson($util.defaultIfNullOrBlank($ctx.args.nextToken, null))
        }
      ResponseMappingTemplate: |
        #**
            Return a flat list of results from a Query or Scan operation.
        *#
        $util.toJson($ctx.result.items)



  SearchUsersResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: searchUsers
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "Scan",
            "filter" : {
              "expression" : "#username <> :myname and begins_with(#username, :username)",
              "expressionNames" : {
                  "#username" : "username"
              },
              "expressionValues" : {
                  ":myname" : {"S": "${context.identity.username}"},
                  ":username" : {"S": "${context.arguments.username}"}
              }
          },
            ## Add 'limit' and 'nextToken' arguments to this field in your schema to implement pagination. **
            ## "limit": $util.defaultIfNull(${ctx.args.limit}, 20),
            ## "nextToken": $util.toJson($util.defaultIfNullOrBlank($ctx.args.nextToken, null))
        }
      ResponseMappingTemplate: |
        #**
            Return a flat list of results from a Query or Scan operation.
        *#
        $util.toJson($ctx.result.items)




  GetUserWalletsResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getUserWallets
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
                "username": $util.dynamodb.toDynamoDBJson($ctx.args.username),
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)

  GetMeResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getMe
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "GetItem",
          "key": {
              "username": { "S" : "${context.identity.username}"}
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)


        

  conversationsUserResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "User"
      FieldName: "conversations"
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "username = :username",
              "expressionValues" : {
                  ":username" : {
                      "S" : "${context.identity.username}"
                  }
              }
          },
          "scanIndexForward": false,
          "limit": 1000
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result.items)
    

  getAllMessagesResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllMessages
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :id",
              "expressionValues" : {
                  ":id" : {
                      "S" : "${context.arguments.conversationId}"
                  }
              }
          },
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result.items)

  getAllMessageConnectionsResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllMessageConnections
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :conversationId",
              "expressionValues" : {
                  ":conversationId" : {
                      "S" : "${context.arguments.conversationId}"
                  }
              }
          },
          "scanIndexForward": false,
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        {
          "messages": $utils.toJson($context.result.items),
          "nextToken": #if(${context.result.nextToken}) "${context.result.nextToken}" #else null #end
        }

  getAllMessagesFromResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllMessagesFrom
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :id and sender = :sender",
              "expressionValues" : {
                  ":id" : {
                      "S" : "${context.arguments.conversationId}"
                  },
                  ":sender" : {
                      "S" : "${context.arguments.sender}"
                  }
              }
          },
          "index" : "sender",
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result.items)

  

  MessagesConversationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Conversation"
      FieldName: "messages"
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :id",
              "expressionValues" : {
                  ":id" : {
                      "S" : "${context.source.id}"
                  }
              }
          },
          "scanIndexForward": false,
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        {
          "messages": $utils.toJson($context.result.items),
          "nextToken": #if(${context.result.nextToken}) "${context.result.nextToken}" #else null #end
        }

  conversationUserConversationBridgeResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: UserConversationBridge
      FieldName: "conversation"
      DataSourceName: !GetAtt ConversationTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "GetItem",
          "key" : {
              "id" : { "S" : "${context.source.conversationId}" }
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)


  associatedUserConversationBridgeResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: UserConversationBridge
      FieldName: associated
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2018-05-29",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :conversationId",
              "expressionValues" : {
                  ":conversationId" : {
                      "S" : "${context.source.conversationId}"
                  }
              }
          },
          "filter" : {
              "expression" : "#username <> :username",
              "expressionNames" : {
                  "#username" : "username"
              },
              "expressionValues" : {
                  ":username" : {"S": "${context.identity.username}"}
              }
          },
          "index": "conversationId-index"
        }
      ResponseMappingTemplate: |
        #if($context.result.items.size() > 0) 
          $util.toJson($context.result.items[0]["username"]) 
        #else 
          null
        #end

  UpdateUserResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateUser
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "UpdateItem",
            "key" : {
                "username" : $util.dynamodb.toDynamoDBJson($context.arguments.username)
            },
            "update" : {
                "expression" : "SET wallets = :wallets",
                ## "expressionNames": {
                ##     "#url" : "url"
                ## },
                "expressionValues": {
                    ":wallets" : $util.dynamodb.toDynamoDBJson($context.arguments.wallets)
                }
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)


  SetReadResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: setRead
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "UpdateItem",
            "key": {
                "username": { "S" : "${context.arguments.username}"},
                "conversationId": { "S" : "${context.arguments.conversationId}"}
            },
            "update" : {
                "expression" : "SET #read = :messageId",
                "expressionNames" : {
                  "#read" : "read"
                },
                "expressionValues": {
                    ":messageId" : $util.dynamodb.toDynamoDBJson($context.arguments.messageId)
                }
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)