
AWSTemplateFormatVersion: '2010-09-09'
Description: AppSync Stack
Parameters:
  ProjectName:
    Type: String
    Default: klubby
    Description: Unique Auth Name for Cognito Resources
  Stage:
    Type: String
    Default: dev
    Description: Stage of build
  UserPoolId:
    Type: AWS::SSM::Parameter::Value<String>
    Default: userpool-id-dev
    Description: user pool id from SSM
  UserTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: user-table-name-dev
    Description: user table name
  ConversationTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: conversation-table-name-dev
    Description: conversation table name
  UserConversationBridgeTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: userconversationbridge-table-name-dev
    Description: user conversation table name
  MessageTableName:
    Type: AWS::SSM::Parameter::Value<String>
    Default: message-table-name-dev
    Description: message table name
Resources:
  GraphQLApi:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      Name: !Sub '${ProjectName}-graphql-${Stage}'
      AuthenticationType: "AMAZON_COGNITO_USER_POOLS"
      UserPoolConfig:
        UserPoolId: !Ref UserPoolId
        AwsRegion: us-east-1
        DefaultAction: ALLOW
        # Ref: defaultAction
  Schema:
    Type: AWS::AppSync::GraphQLSchema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      # DefinitionS3Location:
      #   Ref: graphQlSchemaS3DescriptionLocation
      Definition: |
        schema {
            query: Query
            mutation: Mutation
            subscription: Subscription
        }

        type Conversation {
          #  The Conversation's timestamp.
          createdAt: String
          #  A unique identifier for the Conversation.
          id: ID!
          #  The Conversation's messages.
          messages(after: String, first: Int): MessageConnection
          #  The Conversation's name.
          name: String!
        }

        type Message {
          #  The author object. Note: `authorId` is only available because we list it in `extraAttributes` in `Conversation.messages`
          author: User
          #  The message content.
          content: String!
          #  The id of the Conversation this message belongs to. This is the table primary key.
          conversationId: ID!
          #  The message timestamp. This is also the table sort key.
          createdAt: String
          #  Generated id for a message -- read-only
          id: ID!
          #  Flag denoting if this message has been accepted by the server or not.
          isSent: Boolean
          recipient: User
          sender: String
        }

        type MessageConnection {
          messages: [Message]
          nextToken: String
        }

        type User {
          username: String!
          wallets: String
          #  A user's enrolled Conversations. This is an interesting case. This is an interesting pagination case.
          conversations(after: String, first: Int): UserConversationsConnection
          messages(after: String, first: Int): MessageConnection
        }

        type UserConversations {
          # The other user name
          associated: String
          # The conversation related me
          conversation: Conversation
          # latest message id  which user has read
          read: String

          conversationId: ID!
          username: ID!
        }

        type UserConversationsConnection {
          nextToken: String
          userConversations: [UserConversations]
        }

        type Query {
          #get all users
          getAllUsers: [User]

          # get user wallets
          getUserWallets(username: String!): User

          #  Scan through all values of type 'Message'. Use the 'after' and 'before' arguments with the 'nextToken' returned by the 'MessageConnection' result to fetch pages.
          getAllMessages(after: String, conversationId: ID!, first: Int): [Message]

          #  Scan through all values of type 'MessageConnection'. Use the 'after' and 'before' arguments with the 'nextToken' returned by the 'MessageConnectionConnection' result to fetch pages.
          getAllMessageConnections(after: String, conversationId: ID!, first: Int): MessageConnection

          # TODO what does this do
          getAllMessagesFrom(after: String, conversationId: ID!, first: Int, sender: String!): [Message] 

          # get Me
          getMe: User

          test: User
        }

        type Mutation {
          #  Create a Conversation. Use some of the cooked in template functions for UUID and DateTime.
          createConversation(createdAt: String, id: ID!, name: String!): Conversation

          #  Create a message in a Conversation.
          createMessage(content: String, conversationId: ID!, createdAt: String!, id: ID!): Message

          # Create a user conversation.
          createUserConversationBridge(conversationId: ID!, username: ID!): UserConversations

          # addUser(username: String!): User
          updateUser(username: String!,wallets: String!): User
        }

        type Subscription  {
          #  Subscribes to all new messages in a given Conversation.
          subscribeToNewMessage(conversationId: ID!): Message
            @aws_subscribe(mutations:["createMessage"])
          subscribeToNewUserConversations(username:ID!): UserConversations
            @aws_subscribe(mutations: ["createUserConversationBridge"])
        }

  UserTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "UserDynamoDBTable"
      Description: The Post DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref UserTableName

  ConversationTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "ConversationDynamoDBTable"
      Description: The Conversation DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref ConversationTableName

  UserConversationBridgeTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "UserConversationsDynamoDBTable"
      Description: The User Conversation DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref UserConversationBridgeTableName

  MessageTableDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: "MessageDynamoDBTable"
      Description: Message DynamoDB table
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppSyncDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: "us-east-1"
        TableName: !Ref MessageTableName

  AppSyncDynamoDBRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: Amplify
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: dynamodb:*
                Resource: '*'

  ### Resolvers ###
  TestResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: test
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "GetItem",
          "key": {
              "username": { "S" : "${context.identity.username}"}
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  CreateConversationMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createConversation"
      DataSourceName: !GetAtt ConversationTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "PutItem",
          "key": {
              "id": { "S" : "${context.arguments.id}"}
          },
          "attributeValues" : {
             "id": {  "S": "${context.arguments.id}" },
             "name": {  "S": "${context.arguments.name}" }
             #if(${context.arguments.createdAt}) ,"createdAt": { "S": "${context.arguments.createdAt}"} #end
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  CreateUserConversationBridgeMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createUserConversationBridge"
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "PutItem",
            "key": {
                "username": { "S" : "${context.arguments.username}"},
                "conversationId": { "S" : "${context.arguments.conversationId}"}
            },
            "attributeValues" : {
                "username": {  "S": "${context.arguments.username}" },
                "conversationId": {  "S": "${context.arguments.conversationId}" }
            }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)

  CreateMessageMutationResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "Mutation"
      FieldName: "createMessage"
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "PutItem",
          "key" : {
              "conversationId" : { "S" : "${context.arguments.conversationId}" }
          },
          "attributeValues" : {
              "conversationId": {  "S": "${context.arguments.conversationId}" },
              "content": {  "S": "${context.arguments.content}" },
              "createdAt": {  "S": "${context.arguments.createdAt}" },
              "sender": {  "S": "${context.identity.username}" },
              "isSent": {  "BOOL": true },
              "id": { "S": "${context.arguments.id}" }
          }
        }

      ResponseMappingTemplate: |
        $utils.toJson($context.result)


  GetAllUsersResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllUsers
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "Scan",
            "filter" : {
              "expression" : "#username <> :username",
              "expressionNames" : {
                  "#username" : "username"
              },
              "expressionValues" : {
                  ":username" : {"S": "${context.identity.username}"}
              }
          },
            ## Add 'limit' and 'nextToken' arguments to this field in your schema to implement pagination. **
            ## "limit": $util.defaultIfNull(${ctx.args.limit}, 20),
            ## "nextToken": $util.toJson($util.defaultIfNullOrBlank($ctx.args.nextToken, null))
        }
      ResponseMappingTemplate: |
        #**
            Return a flat list of results from a Query or Scan operation.
        *#
        $util.toJson($ctx.result.items)

  GetUserWalletsResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getUserWallets
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version": "2017-02-28",
            "operation": "GetItem",
            "key": {
                "username": $util.dynamodb.toDynamoDBJson($ctx.args.username),
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)

  GetMeResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getMe
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "GetItem",
          "key": {
              "username": { "S" : "${context.identity.username}"}
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)
    
  

  messagesUserResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "User"
      FieldName: "messages"
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "sender = :id",
              "expressionValues" : {
                  ":id" : {
                      "S" : "${context.identity.username}"
                  }
              }
          },
          "index": "sender-conversationId-index",
          "scanIndexForward": false,
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        {
          "messages": $utils.toJson($context.result.items),
          "nextToken": #if(${context.result.nextToken}) "${context.result.nextToken}" #else null #end
        }


  conversationsUserResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: "User"
      FieldName: "conversations"
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "username = :username",
              "expressionValues" : {
                  ":username" : {
                      "S" : "${context.identity.username}"
                  }
              }
          },
          "scanIndexForward": false,
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        {
          "userConversations": $utils.toJson($context.result.items),
          "nextToken": #if(${context.result.nextToken}) "${context.result.nextToken}" #else null #end
        }

  getAllMessagesResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllMessages
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :id",
              "expressionValues" : {
                  ":id" : {
                      "S" : "${context.arguments.conversationId}"
                  }
              }
          },
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result.items)

  getAllMessageConnectionsResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllMessageConnections
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :conversationId",
              "expressionValues" : {
                  ":conversationId" : {
                      "S" : "${context.arguments.conversationId}"
                  }
              }
          },
          "scanIndexForward": false,
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        {
          "messages": $utils.toJson($context.result.items),
          "nextToken": #if(${context.result.nextToken}) "${context.result.nextToken}" #else null #end
        }

  getAllMessagesFromResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAllMessagesFrom
      DataSourceName: !GetAtt MessageTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :id and sender = :sender",
              "expressionValues" : {
                  ":id" : {
                      "S" : "${context.arguments.conversationId}"
                  },
                  ":sender" : {
                      "S" : "${context.arguments.sender}"
                  }
              }
          },
          "index" : "sender",
          "limit": #if(${context.arguments.first}) ${context.arguments.first} #else 20 #end,
          "nextToken": #if(${context.arguments.after}) "${context.arguments.after}" #else null #end
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result.items)

  conversationUserConversationsResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: UserConversations
      FieldName: "conversation"
      DataSourceName: !GetAtt ConversationTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "GetItem",
          "key" : {
              "id" : { "S" : "${context.source.conversationId}" }
          }
        }
      ResponseMappingTemplate: |
        $utils.toJson($context.result)


  associatedUserConversationsResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: UserConversations
      FieldName: associated
      DataSourceName: !GetAtt UserConversationBridgeTableDataSource.Name
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
              "expression": "conversationId = :conversationId",
              "expressionValues" : {
                  ":conversationId" : {
                      "S" : "${context.source.conversationId}"
                  }
              }
          },
          "filter" : {
              "expression" : "#username <> :username",
              "expressionNames" : {
                  "#username" : "username"
              },
              "expressionValues" : {
                  ":username" : {"S": "${context.identity.username}"}
              }
          },
          "index": "conversationId-index"
        }
      ResponseMappingTemplate: |
        $util.toJson($context.result.items[0]["username"])

  UpdateUserResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Mutation
      FieldName: updateUser
      DataSourceName: !GetAtt UserTableDataSource.Name
      RequestMappingTemplate: |
        {
            "version" : "2017-02-28",
            "operation" : "UpdateItem",
            "key" : {
                "username" : $util.dynamodb.toDynamoDBJson($context.arguments.username)
            },
            "update" : {
                "expression" : "SET wallets = :wallets",
                ## "expressionNames": {
                ##     "#url" : "url"
                ## },
                "expressionValues": {
                    ":wallets" : $util.dynamodb.toDynamoDBJson($context.arguments.wallets)
                }
            }
        }
      ResponseMappingTemplate: |
        ## Pass back the result from DynamoDB. **
        $util.toJson($ctx.result)